<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript中的对象创建 | whilter的个人博客</title>
    <meta name="description" content="my personal blog">
    <link rel="stylesheet" href="/css/iconfont.css">
    
    <link rel="preload" href="/assets/css/0.styles.fdd41da0.css" as="style"><link rel="preload" href="/assets/js/app.f447d40f.js" as="script"><link rel="preload" href="/assets/js/3.53cc69ce.js" as="script"><link rel="preload" href="/assets/js/14.244ee39a.js" as="script"><link rel="prefetch" href="/assets/js/10.70c39f12.js"><link rel="prefetch" href="/assets/js/11.64fe07e1.js"><link rel="prefetch" href="/assets/js/12.c96cfe7b.js"><link rel="prefetch" href="/assets/js/13.35238eaa.js"><link rel="prefetch" href="/assets/js/15.1c673625.js"><link rel="prefetch" href="/assets/js/16.22291763.js"><link rel="prefetch" href="/assets/js/2.39d70fc7.js"><link rel="prefetch" href="/assets/js/4.0ad9f009.js"><link rel="prefetch" href="/assets/js/5.8572406e.js"><link rel="prefetch" href="/assets/js/6.85747e29.js"><link rel="prefetch" href="/assets/js/7.122278c1.js"><link rel="prefetch" href="/assets/js/8.72c477ba.js"><link rel="prefetch" href="/assets/js/9.b3a85d05.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fdd41da0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="main-layout" data-v-6b28200e><div id="content" data-v-6b28200e><div class="sidebar content-side" data-v-6b28200e><div class="return-home" data-v-6b28200e><span class="blog-img" data-v-6b28200e></span>whilter的个人博客</div> <ul class="headers-list" data-v-6b28200e><h3 data-v-6b28200e>JavaScript中的对象创建</h3> <li title="Object类型介绍" style="padding-left:0rem;" data-v-6b28200e>
          Object类型介绍
        </li><li title="创建对象的方法" style="padding-left:0rem;" data-v-6b28200e>
          创建对象的方法
        </li><li title="Object和对象字面量" style="padding-left:1.2rem;" data-v-6b28200e>
          Object和对象字面量
        </li><li title="工厂模式" style="padding-left:1.2rem;" data-v-6b28200e>
          工厂模式
        </li><li title="构造函数模式" style="padding-left:1.2rem;" data-v-6b28200e>
          构造函数模式
        </li><li title="原型模式" style="padding-left:1.2rem;" data-v-6b28200e>
          原型模式
        </li><li title="组合使用构造函数模式与原型模式" style="padding-left:1.2rem;" data-v-6b28200e>
          组合使用构造函数模式与原型模式
        </li><li title="动态原型模式、寄生构造函数模式、稳妥构造函数模式" style="padding-left:1.2rem;" data-v-6b28200e>
          动态原型模式、寄生构造函数模式、稳妥构造函数模式
        </li><li title="继承" style="padding-left:0rem;" data-v-6b28200e>
          继承
        </li><li title="原型链" style="padding-left:1.2rem;" data-v-6b28200e>
          原型链
        </li><li title="借用构造函数" style="padding-left:1.2rem;" data-v-6b28200e>
          借用构造函数
        </li><li title="组合继承" style="padding-left:1.2rem;" data-v-6b28200e>
          组合继承
        </li></ul></div> <div class="container" style="overflow: auto" data-v-6b28200e><div class="page-content" data-v-6b28200e><div class="content__default" data-v-6b28200e><h1 id="javascript中的对象创建"><a href="#javascript中的对象创建" class="header-anchor">#</a> JavaScript中的对象创建</h1> <hr> <h2 id="object类型介绍"><a href="#object类型介绍" class="header-anchor">#</a> Object类型介绍</h2> <p>ECMAScript中的对象其实就是一组数据与功能的集合，Object是所有对象的基础，由于原型链的原因，所有继承于Object的对象都具有Object的基本属性和方法：</p> <div class="custom-block tip"><p class="custom-block-title">如下</p> <ol><li><p><strong>constructor</strong>：保存着用于创建当前对象的函数</p></li> <li><p><strong>hasOwnProperty</strong>：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其参数必须是字符串</p></li> <li><p><strong>isPrototypeOf(object)</strong>：用于检查传入的对象是否是当前对象的原型</p></li> <li><p><strong>toLocaleString()</strong>：返回对象的字符串表示，该字符串与执行环境的地区对应</p></li> <li><p><strong>toString()</strong>：返回对象的字符串表示</p></li> <li><p><strong>valueOf()</strong>：返回对象的字符串、数值、或布尔值表示。通常与toString()方法的返回值相同</p></li></ol></div> <h2 id="创建对象的方法"><a href="#创建对象的方法" class="header-anchor">#</a> 创建对象的方法</h2> <h3 id="object和对象字面量"><a href="#object和对象字面量" class="header-anchor">#</a> Object和对象字面量</h3> <p>创建对象最简单的方法就是使用对象字面量或者Object构造函数，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">//对象字面量方式</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'whilter'</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//Object构造函数</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'whilter'</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">优点</p> <p>创建方式简单，代码量少且易理解，创建单个对象时使用方便快捷。</p></div> <div class="custom-block danger"><p class="custom-block-title">缺点：</p> <p>创建相同的多个对象时，会产生大量重复代码</p></div> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h3> <p>工厂模式是用函数将创建对象的细节进行封装，函数内部返回封装完成的对象，示例代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>sex</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    person<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    person<span class="token punctuation">.</span>sex <span class="token operator">=</span>sex<span class="token punctuation">;</span>
    person<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> person<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">优点</p> <p>可以批量创建对象，不会产生重复代码</p></div> <div class="custom-block danger"><p class="custom-block-title">缺点</p> <p>无法对对象进行识别，即无法知道对象的类型</p></div> <h3 id="构造函数模式"><a href="#构造函数模式" class="header-anchor">#</a> 构造函数模式</h3> <p>js中存在一些原生构造函数，比如Array、Object等，可以使用这些创建相关对象，此外，也可以创建自定义的构造函数，从而定义自定义对象的属性和方法。示例如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'whilter'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">'men'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>构造函数一般以大写字母开头，这个做法借鉴于其他OO语言，主要是为了区别于普通函数，要创建Person的实例，必须使用new操作符，以这种方式调用构造函数，实际上会经历以下4个步骤</p> <blockquote><p>1、创建一个新的对象</p></blockquote> <blockquote><p>2、将构造函数的作用域赋给新对象（将this指向新对象）</p></blockquote> <blockquote><p>3、执行构造函数中的代码（为新对象添加属性）</p></blockquote> <blockquote><p>4、返回新对象</p></blockquote> <p>上面已经说过，每个对象都有一个基本属性constructor，这里通过Person创建的实例，其constructor属性就指向Person，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//true</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">优点</p> <p>批量创建对象，同时不会显式创建、返回对象，减少代码量，此外通过这种方式可以将其实例标识为一种特定的类型</p></div> <div class="custom-block danger"><p class="custom-block-title">缺点</p> <p>对象中的每个方法都要在实例中创建一遍，函数（Function）也是对象，因此在每个实例中的方法是不相等的，然而创建两个完成同样任务的Function实例完全没有必要</p></div> <h3 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h3> <p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享方法的属性和方法。使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。因此我们可以通过将这些信息直接添加到原型对象中，以此来创建对象，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'whilter'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'men'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注：<em>虽然可以通过访问对象实例来访问保存在原型中的值，但是不能通过对象实例重写原型中的值，若在实例对象中添加一个原型已存在的属性，则将在实例中创建该属性，访问时，按原型链查找，会优先访问实例中的该属性，若不存在，才会向上查找原型中的属性</em></p> <div class="custom-block warning"><p class="custom-block-title">优点</p> <p>所有实例对象都将共享同一属性和方法，避免了同一属性和方法的多次定义，且由于原型的动态性，在修改原型属性和方法时，所有实例都将同步修改，不论实例创建在修改前还是修改后。</p></div> <div class="custom-block danger"><p class="custom-block-title">缺点</p> <p>由于原型的属性和方法被所有实例所共享以及原型的动态性，对于包含引用类型值的属性来说，实例将无法拥有私有值，单个实例修改该属性，将导致所有实例值一起发生改变，因此单独使用原型模式时非常不合适的选择</p></div> <h3 id="组合使用构造函数模式与原型模式"><a href="#组合使用构造函数模式与原型模式" class="header-anchor">#</a> 组合使用构造函数模式与原型模式</h3> <p>这种方式是最常见的创建自定义对象的方式，通过以上总结的优缺点，可以发现，构造函数模式适合于定义实例私有属性，而原型模式则适用于定义方法和共享属性。这样，每个实例都将拥有自己的一份实例属性副本，同时又共享着对方法的引用，最大限度的节省了内存，例子如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Mary'</span><span class="token punctuation">,</span><span class="token string">'Bob'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'whilter'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'men'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Mary'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'women'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends <span class="token operator">==</span> person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">==</span> person2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
</code></pre></div><h3 id="动态原型模式、寄生构造函数模式、稳妥构造函数模式"><a href="#动态原型模式、寄生构造函数模式、稳妥构造函数模式" class="header-anchor">#</a> 动态原型模式、寄生构造函数模式、稳妥构造函数模式</h3> <p>略~</p> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p>许多OO语言都支持两种继承方式：接口继承和实现继承。但是由于ECMAScript函数没有签名，所有无法实现接口继承，只能实现实现继承，而其实现方式是依靠原型链来完成的。</p> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'whilter'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">-</span><span class="token operator">&gt;</span> Person Prototype
person<span class="token punctuation">[</span><span class="token punctuation">[</span>Prototype<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Person Prototype
Person <span class="token class-name">Prototype</span><span class="token punctuation">.</span>constructor <span class="token operator">-</span><span class="token operator">&gt;</span> Person
person<span class="token punctuation">.</span>constructor <span class="token operator">-</span><span class="token operator">&gt;</span> Person
</code></pre></div><p>此时若将原型对象等于另一个类型的实例，则此原型对象将拥有了一个指向另一类型原型对象的私有指针（[[Prototype]]，部分浏览器中也叫__proto__），依次类推，就形成了实例与原型的链条，这就是原型链的基本概念,如图所示：</p> <p><img src="/images/prototype.png" alt="原型链示意图"></p> <h4 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="header-anchor">#</a> 确定原型和实例的关系</h4> <p>有两种方式来确定原型和实例之间的关系。</p> <ul><li>使用instanceof操作符</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//true</span>
</code></pre></div><ul><li>使用isPrototypeOf()方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//true</span>
</code></pre></div><p><strong>原型链的缺点</strong>
和通过原型模式创建对象一样，原型链也存在引用类型被所有实例共享的问题，同时，没有办法在不影响所有对象实例的情况下，向超类型的构造函数中传递参数。因此在实践中很少会单独使用原型链。</p> <h3 id="借用构造函数"><a href="#借用构造函数" class="header-anchor">#</a> 借用构造函数</h3> <p>这种技术的实现思路是在子类型构造函数的内部调用超类型构造函数。如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 'red, blue, green, black'</span>

<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 'red, blue, green'</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">优点</p> <p>可以在子类型构造函数中向超类型构造函数传递参数</p></div> <div class="custom-block danger"><p class="custom-block-title">缺点</p> <p>方法都在构造函数中定义，出现重复定义，而且超类型的原型中定义的方法，对子类型来说是不可见的，因此借用构造函数也是很少单独使用的</p></div> <h3 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h3> <p>这种方式是将原型链和借用构造函数的技术组合到一起，各发挥其所长的一种继承模式</p></div></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f447d40f.js" defer></script><script src="/assets/js/3.53cc69ce.js" defer></script><script src="/assets/js/14.244ee39a.js" defer></script>
  </body>
</html>
